<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <base href="/Nozy-wallet/">
    <link
      rel="icon"
      type="image/svg+xml"
      href="assets/logo.png"
    />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <meta
      name="keywords"
      content="privacy wallet, zcash wallet, monero alternative, private cryptocurrency, untraceable transactions, zero-knowledge proofs, shielded transactions"
    />
    <meta
      name="description"
      content="NozyWallet is the only Zcash wallet that enforces complete privacy for every transaction. Same privacy as Monero, but faster and more efficient. Privacy by default."
    />
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <title>
      NozyWallet - Privacy by Default | Monero-Level Privacy, Zcash Speed
    </title>
    <script type="module" crossorigin src="assets/index-CSzPK1kz.js"></script>
    <link rel="stylesheet" crossorigin href="assets/index-Zl7hyVsg.css">
    <script>
        // Wait for React app to fully load, then modify download buttons
        (function() {
            let attempts = 0;
            const maxAttempts = 20; // Try for 10 seconds (20 * 500ms)
            
            function modifyDownloadButtons() {
                attempts++;
                
                // Find all possible download buttons/links
                const selectors = [
                    'a[href*="download"]',
                    'button:has-text("download")',
                    'a:has-text("Download")',
                    'button:has-text("Download")',
                    '[role="button"]:has-text("download")',
                    'a',
                    'button'
                ];
                
                let foundButtons = false;
                
                // Try to find download buttons by text content
                document.querySelectorAll('a, button, [role="button"], [onclick*="download"]').forEach(element => {
                    const text = (element.textContent || '').toLowerCase();
                    const href = element.getAttribute('href') || '';
                    const onclick = element.getAttribute('onclick') || '';
                    const className = element.className || '';
                    
                    // Check if it's a download button
                    if (text.includes('download') || 
                        href.toLowerCase().includes('download') || 
                        onclick.toLowerCase().includes('download') ||
                        className.toLowerCase().includes('download')) {
                        
                        foundButtons = true;
                        
                        // Remove existing handlers
                        element.onclick = null;
                        element.removeAttribute('onclick');
                        
                        // Set new behavior
                        if (element.tagName === 'A') {
                            element.href = 'downloads/';
                            element.setAttribute('href', 'downloads/');
                        } else {
                            element.addEventListener('click', function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                window.location.href = 'downloads/';
                                return false;
                            }, true);
                        }
                        
                        // Also handle any React onClick handlers
                        const reactProps = Object.keys(element).filter(key => key.startsWith('__react'));
                        reactProps.forEach(prop => {
                            try {
                                const reactFiber = element[prop];
                                if (reactFiber && reactFiber.memoizedProps) {
                                    if (reactFiber.memoizedProps.onClick) {
                                        const originalOnClick = reactFiber.memoizedProps.onClick;
                                        reactFiber.memoizedProps.onClick = function(e) {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            window.location.href = 'downloads/';
                                            return false;
                                        };
                                    }
                                }
                            } catch (e) {
                                // Ignore errors
                            }
                        });
                    }
                });
                
                // If we found buttons or tried enough times, stop
                if (foundButtons || attempts >= maxAttempts) {
                    if (foundButtons) {
                        console.log('âœ… Modified download buttons');
                    }
                } else {
                    // Try again after a delay
                    setTimeout(modifyDownloadButtons, 500);
                }
            }
            
            // Start trying immediately
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', modifyDownloadButtons);
            } else {
                modifyDownloadButtons();
            }
            
            // Also watch for dynamically added elements
            const observer = new MutationObserver(function(mutations) {
                modifyDownloadButtons();
            });
            
            observer.observe(document.body || document.documentElement, {
                childList: true,
                subtree: true,
                attributes: true,
                attributeFilter: ['href', 'onclick']
            });
            
            // Also try on window load
            window.addEventListener('load', modifyDownloadButtons);
            
            // Global click interceptor - catch download button clicks at document level
            document.addEventListener('click', function(e) {
                const target = e.target;
                const text = (target.textContent || '').toLowerCase();
                const href = target.getAttribute('href') || '';
                const className = target.className || '';
                const id = target.id || '';
                
                // Check if clicked element is a download button
                if (text.includes('download') || 
                    href.toLowerCase().includes('download') || 
                    className.toLowerCase().includes('download') ||
                    id.toLowerCase().includes('download')) {
                    
                    // Check if it's not already pointing to downloads/
                    if (!href.includes('downloads/') && !href.includes('downloads.html')) {
                        e.preventDefault();
                        e.stopPropagation();
                        window.location.href = 'downloads/';
                        return false;
                    }
                }
                
                // Also check parent elements (for nested structures)
                let parent = target.parentElement;
                for (let i = 0; i < 3 && parent; i++) {
                    const parentText = (parent.textContent || '').toLowerCase();
                    const parentHref = parent.getAttribute('href') || '';
                    const parentClass = parent.className || '';
                    
                    if (parentText.includes('download') && 
                        !parentHref.includes('downloads/') &&
                        (parent.tagName === 'A' || parent.tagName === 'BUTTON')) {
                        e.preventDefault();
                        e.stopPropagation();
                        window.location.href = 'downloads/';
                        return false;
                    }
                    parent = parent.parentElement;
                }
            }, true); // Use capture phase to catch before React handlers
        })();
    </script>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>
